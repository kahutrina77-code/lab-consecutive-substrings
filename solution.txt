CONSECUTIVE SUBSTRINGS SOLUTION


SOLUTION DESCRIPTION  


Algorithm Type: Nested Loop (Brute Force)

Why I chose this:
- Guarantees finding all consecutive substrings
- Straightforward to implement and understand
- Systematically checks every start-end position combination

How it works:
The outer loop (i) iterates through each character as a starting position.
The inner loop (j) iterates from that start to the end of the string.
For each i,j pair, slice(i, j+1) extracts the substring and adds it to results.

Example with "abc":
- i=0: generates "a", "ab", "abc"
- i=1: generates "b", "bc"
- i=2: generates "c"


TIME COMPLEXITY


Time Complexity: O(n³)

Detailed breakdown:
- Outer loop: runs n times (O(n))
- Inner loop: runs n(n+1)/2 times total (O(n²))
- slice() operation: copies characters, takes O(n) time
- Combined: O(n) × O(n) × O(n) = O(n³)

Space Complexity: O(n²)
- Number of substrings: n(n+1)/2 ≈ O(n²)


SCALABILITY


When string length doubles, execution time increases by ~8x (2³ = 8).

For the e-commerce use case, this is suitable since search queries 
are typically short (< 50 characters).